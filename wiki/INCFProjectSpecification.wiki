INCF Atlas Hub Specification and INCF Atlasing Infrastructure Overview
Version 0.4, March 2010. 
Digital Atlasing Infrastructure Task Force
I. Zaslavsky, editor
Introduction
This document specifies INCF atlas hub services (part 1), reviews their place in the Atlasing infrastructure, including their registration at INCF Central server (part 2), provides draft specifications for coordinate spaces and coordinate transformations that represent the backbone of the infrastructure (part 3), list INCF Central services (part 4) and describes different types of hubs and their implementation model (parts 5-6).  The document derives from an earlier report of the INCF Digital Atlasing Task Force, and provides additional details about INCF service oriented architecture (SOA) as explored during the September’09 atlas integration demo. As of version 0.4, it also incorporates initial comments from members of the Digital Atlasing Infrastructure Task Force and INSF research staff. 
Portions of this document are under discussion at the “INCF standards” page https://confluence.crbs.ucsd.edu/display/SISL/INCF+Standards 
The INCF SOA relies, where possible, on
-	standard service descriptions and exchange schemas;
-	standardized coordinate reference systems, and a service-accessible registry of reference systems;
-	a collection of coordinate transformation services, with Waxholm Space (WHS) at the center;
-	standardized data models for the types of neuroscience data incorporated in the SOA;
-	standard terminology explicated in registered ontologies and available via term cross-walks where needed.
We anticipate that a community process is organized by which atlas services and their output schema are discussed and adopted as international standards. The schemas presented below are merely first approximations of such schemas. If appropriate, we leverage schemas developed and adopted in neighboring domains. 
The work with this document is envisioned as follows: 
-	Initial development and editing, with contributions from DAI members and INCF research staff (to be completed within 1 month after the Edinburgh meeting in late March 2010);
-	Pilot implementations demonstrating the services (ongoing)
-	The document is posted on the INCF site, with a two-month RFC time (May-June)
-	Responses to the comments and discussion within DAI (July-August)
-	The specification is presented as a DAI-recommended standard, by the III Neuroscience Congress in Kobe (end of August – September).
1. INCF atlas hub and atlas services
An INCF Atlas Hub hosts a collection of web services that provide access to hub’s resources, as well as translations from specific atlas spatial reference systems (SRS) or vocabularies local to the hub, to INCF-supported WHS reference system and NIF ontology respectively. The discussion below is based on our initial experience developing the current alpha phase of atlas services within the WHS Server prototype project supported by INCF. Currently, the services represent a collection of HTTP GET requests. We attempted to make these requests uniform across different hubs, to the extent possible. Hardening and testing the services, and implementing the services over production-level data management infrastructure, are the next steps – which shall rely on discussing and pruning service signatures and finalizing the output schema to the extent possible within the current phase of the project.
Often, resources served by a particular hub may go beyond atlas services specifically. They may include, for example, services for other types of data, database and registry management and harvesting tools, collaboration and other applications. We refer to such servers as “Neurohubs”. 
The different service types are listed in a local NeuroHub service registry (or Neurohub capabilities service).  The NeuroHub service registry may follow the CSW specification (http://www.opengeospatial.org/standards/cat) , or any other convenient specification, or just generate a custom capability document on a hub-level GetCapabilities request. This organization is shown in Figure 1 below. The subordinate services would follow established service interface specifications (if available), and should include a GetCapabilities method describing the content of the service. Since we rely on individual GetCapabilities requests for each subordinate service, catalog record descriptions returned on the NeuroHub GetCapabilities call may be quite terse (basically, service type and endpoint, plus general Dublin core metadata for the hub.) 
 
Figure 1. General composition of NeuroHub services

In the discussion below, atlas services represent a type of functionality that may be provided by a Neurohub, and establish a model for the latter. Atlas services may include several protocols: WaxML service specification (described below), WMS (Web Map Service, http://www.opengeospatial.org/standards/wms), WPS (Web Processing Service, http://www.opengeospatial.org/standards/wps - likely to be used for transformations and other processing functions), 3D visualization service (to be specified), etc.
General request format
In the current version, the atlas services are modeled after WPS interface specification. They are invoked via requests such as
http://<server-path>/HostServiceController?Service=WPS&version=1.0.0
&request=<WPS_Request>&Identifier=<identifier_name>
& ResponseForm ={format}
&DataInputs={Encoded Inputs}
Note: the above is a recommended WPS-compliant syntax (WPS, or Web Processing Service specification, is selected here as a generic way of describing web functionality that supports several bindings, allows service chaining with BPEL4WS, and has many implementations). It is referenced below). 
So far, the services we developed for the demo followed a simplified request format:
http://<server-path>/HostServiceController?request=<request_name>
&output={format} 
&otherparameter=parametervalue…
The “HostServiceController” (with instances such as ABAServiceController, WHSServiceController, etc.) is a generic service name used throughout the project (its name underscores that in many cases the atlas service merely “controls” or “wraps” services or functions that already exist at individual hubs). The “request” or “WPS_Request” is a mandatory element referring to a name of the method to execute (e.g. GetCapabilities, GetTransformationInfo). In most cases, “output” or “ResponseForm” is also expected, and can be “XML” or “HTML”, or another type (e.g. some image type, or json, yaml) – as supported by the server. The exception is GetCapabilities and similar calls which are expected to generate XML only. The “HTML” output type, in most cases, represents a pass-through to HTML pages or requests at individual hubs. It merely instructs the parser to open a new browser page and display the returned content in its original style. The “HTML” output is easy to implement, and it has been the first output type implemented in the initial service demonstration. The “XML” output type follows output schemas which still need to be determined in most cases. Draft service output specifications are presented below. They are expected to follow Waxholm Markup Language (WaxML), a working name for an output schema that we are designing to provide a uniform service foundation for different hubs. Where other standards are available (e.g. for gene expression data, for generic web processing functionality, for coordinate information) the respective elements will be presented in their own namespaces. Other input parameters vary depending on the type of request. In the WPS-compliant call syntax, “identifier” can be used in some calls (e.g. DescribeProcess) to present a comma-separated list of methods to be described (alternately, “all” can be used).
Some of the conventions adopted throughout WaxML and the services, include:
-	Where feasible, objects and properties are described by a triad e.g. propertyCode, propertyName and propertyDescription. The “code” is expected to be unique within a hub. Names and Descriptions don’t need to be unique. For example, a propertyCode may be “HIP” (or some numeric code), propertyName may be “Hippocampus”, and propertyDescription may be “Hippocampal area”. Either propertyCode or propertyName may double up as a Label for display purposes. Similarly, spatial reference systems may have a SRSCode (e.g. Waxholm_1.0), SRSName (Waxholm Space), and SRSDescription (the original version of the Waxholm reference dataset.). There is also a propertyID usually, but that is autoassigned in a DB.
-	The naming standard for Neurohub service methods we generally follow is:
o	List:  list objects without a query. These requests should support paging capabilities, and enable harvesting.
o	Describe: returns a single object using a persistent identifier
o	Get:  returns one or more objects using a submitted query, or a pointer to a service
-	Objects and properties can be specified in a globally unique way by prepending their codes with a respective hub and coordinate space or vocabulary name, in the form hub:{srs|vocabulary}:code, e.g. ABA:ABAvoxel:HIP (which stands for Hippocampus labeled “HIP” in the vocabulary associated with the ABAvoxel volume and served from the ABA hub). SRS stands for “Spatial Reference System”. Depending on the context, the hub prefix can be omitted. 
-	The general agreement is that XML elements (and UML classes, interfaces, associations, packages, states, use cases, actors) are specified in UpperCamelCase, while attributes (as well as UML attributes, roles, operations, stereotypes, instances, events, actions) follow the lowerCamelCase convention. This is generally consistent with business practices (e.g. http://xml.coverpages.org/ebXML-TechArchv104.pdf) 
-	While the above capitalization rules shall be generally followed, parsers should be case-insensitive.
-	Services should support paging
-	Services should support authentication/authorization (where required). In case of atlas data, authorization would be at the level of spatial registry records.
-	Services should provide a mechanism for retrieving the best quality record: e,g, multiple versions of the same image may be registered in a spatial registry, but given preferences setup by hub manager, only the most recent version may be available by default (other versions would require authorization)
-	As additional service types get developed, they would be registered under the same NeuroHub service.
Types of service requests
Eight types of service requests within Atlas Services are considered:
1)	Core capability descriptions: GetCapabilities and DescribeProcess. These methods shall be implemented for each group of service protocols at each hub.
2)	Basic information about the content of the services, harvested by INCF central server: ListGenes, ListStructures, etc.
3)	Descriptions of available spatial reference systems: ListSRSs, DescribeSRS (also, possibly, ListFeatures and DescribeFeature, ListFiducials and DescribeFiducial, etc.). These methods are expected to be supported by an atlas hub, even if the locally-used Spatial Reference System (SRS) is not unique for the hub. The ListSRSs and DescribeSRS should be also supported at the central server.
4)	Spatial transformations: ListTransformations, DescribeTransformation, GetTransformationChain, TransformPOI. These methods should be supported by the INCF central server and by those hubs that rely on a local coordinate system; others may use centrally stored transformations without declaring their own. 
5)	Structure Lookup: GetStructureNamesByPOI. This method should support structure lookup for canonical set of segmentations of each atlas (we expect that an atlas comes with a single set of “authoritative” segmentations. If there are multiple versions of the segmentations by the maintainer of the canonical space, the latest version is returned (unless an earlier version is requested explicitly).
6)	Other POI-based methods. Most of these methods are likely to be implemented at just one or a handful of hubs. They include: Get2DImagesByPOI; GetCorrelationMapByPOI; GetGenesByPOI, etc. To the extent possible, method signatures have been made uniform across different hubs. 
7)	Other methods, including those based on structure names, e.g. GetGenesByStructure. While these requests do not refer to atlas coordinate spaces, or WHS, directly, they may be the only way to connect to atlases for which spatial transformations have not been or cannot be developed, but ontology cross-walks exist. 
8)	Registration, monitoring and subscription/notification services. These are undefined, at present, but include methods to register a hub with the central server, a method to list all hubs (at the central server), and an “I’m alive” service monitor to alert the central server of a hubs status, and workload. 

In the future, another group of methods, which supports exchanging location information between atlases as spatial placement rules (as described in the INCF Atlasing task force report), will be developed.

We also envision various convenience APIs to be developed over the basic atlas services, as well as additional language bindings (e.g. Python). For example, translating image corners from a source SRS to a target SRS, to correctly position an image in a 2D or 3D viewer that uses the target SRS is often difficult because image corners may be outside valid value ranges. To resolve this problem, a simple approximate technique may be used (e.g. transforming the center point of an image along with four vertices of a small congruent rectangle with the same centerpoint, then extrapolating the transformed values). Such a service (“TransformImageRectangle”) may use a series of the core TransformPOI calls.
Web Processing Service basics

The Web Processing Service (WPS) 1.0.0 specification is available at http://www.opengeospatial.org/standards/wps. The base request in WPS is:
http://<server-path>/HostServiceController?Service=WPS
With WPS, services can be programmed to be chained together to form a workflow, so the URL parameter, DataInputs, is encoded in a method that will allow for chaining. 
 DataInputs=Field1=Value1@Field2=Value2
In order to discover the available processing services at a node, a client would invoke the service, and ask for a capabilities document (see below).
{BaseServiceUrl}&request=GetCapabilities
Full descriptions of the processes are done with a DescribeProcess call:
{BaseServiceUrl}&version=1.0.0&request=DescribeProcess&Identifier={ProcessToDescribe}
Specific method definitions:
The specific method names and output signatures is what has been implemented or proposed as of this draft, and is subject to further edits.
1.	GetCapabilities. This is a mandatory service to be implemented by a group of services at a hub. For atlas services, it complies with OGC’s WPS 1.0.0 specification. The request is

{BaseService}?request=GetCapabilities
The following example method signature was implemented as of 9/2009:
http://incf-dev-mapserver.crbs.ucsd.edu:8080/incf-services/service/ABAServiceController?request=GetCapabilities&output=xml
The response contains hub’s Dublin core metadata, and a list of supported methods. 
The sample output is:
 
<?xml version="1.0" encoding="UTF-8"?>
<wps:Capabilities xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.opengis.net/wps" xmlns:wps="http://www.opengis.net/wps" xmlns:ows="http://www.opengis.net/ows" version="1.0.0" xmlns:ogc="http://www.opengis.net/ogc" xmlns:xlink="http://www.w3.org/1999/xlink" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsGetCapabilities_request.xsd">
	<ows:ServiceIdentification xmlns:ows="http://www.opengis.net/ows">
		<ows:Title>ABA Services</ows:Title>
		<ows:Abstract>ABA Services are created to access various ABA hub features. The services are either implemented at the INCF central server, or represent wrappers of ABA API calls implemented at the ABA site.</ows:Abstract>
		<ows:ServiceType>WPS</ows:ServiceType>
		<ows:ServiceTypeVersion>0.2.41.0.0</ows:ServiceTypeVersion>
		<ows:Fees>NONE</ows:Fees>
		<ows:AccessConstraints>NONE</ows:AccessConstraints>
	</ows:ServiceIdentification>
	<ows:ServiceProvider>
		<ows:ProviderName>Asif Memon</ows:ProviderName>
		<ows:ServiceContact>amemon@ncmir.ucsd.edu</ows:ServiceContact>
	</ows:ServiceProvider>
	<ows:OperationsMetadata>
		<ows:Operation name="GetCapabilities" />
	</ows:OperationsMetadata>
	<wps:ProcessOfferings>
		<wps:Process>
			<ows:Identifier>GetCorrelationMapByPOI</ows:Identifier>
			<ows:Title>Get Correlation Map</ows:Title>
			<ows:Description>This method will return the URL and load the correlation map interface in the browser, for a point of interest (POI) in a specified Spatial Reference System (SRS) </ows:Description>
		</wps:Process>
		<wps:Process>
			<ows:Identifier>GetStructureNamesByPOI</ows:Identifier>
			<ows:Title>Get structure name by POI</ows:Title>
			<ows:Description>Returns Fine/Anatomic structures segmented for the POI in  a specified SRS </ows:Description>
		</wps:Process>
		<wps:Process>
			<ows:Identifier>Get2DImagesByPOI</ows:Identifier>
			<ows:Title>Get 2D Image at POI</ows:Title>
			<ows:Description>Returns 2 Dimensional image given a POI in  a specified SRS </ows:Description>
		</wps:Process>
		<wps:Process>
			<ows:Identifier>GetGenesByPOI</ows:Identifier>
			<ows:Title>Get genes by POI</ows:Title>
			<ows:Description>Returns genes detected at a POI in  a specified SRS </ows:Description>
		</wps:Process>
		<wps:Process>
			<ows:Identifier>GetGenesByStructureName</ows:Identifier>
			<ows:Title>Get genes by Structure Name</ows:Title>
			<ows:Description>Returns genes detected for structure name at a specified vocabulary</ows:Description>
		</wps:Process>
		<wps:Process>
			<ows:Identifier>TransformPOI</ows:Identifier>
			<ows:Title>Atlas Space Transformation from WHS and one or more coordinate spaces local to the hub </ows:Title>
			<ows:Description>Finds, transforms and executes the best coordinate transformation between WHS, ABAvoxel, ABAreference, and AGEA spaces</ows:Description>
		</wps:Process>
	</wps:ProcessOfferings>
	<wps:Languages>
		<wps:Default>
			<ows:Language>en-US</ows:Language>
		</wps:Default>
		<wps:Supported>
			<ows:Language>en-US</ows:Language>
		</wps:Supported>
	</wps:Languages>
</wps:Capabilities>

2.	DescribeProcess. This method describes inputs and outputs of each of the requests implemented at the hub. It follows the WPS schema, as the request above. The base request is 

{BaseService}request=DescribeProcess
And an example method call (as implemented) is:
http://incf-dev-mapserver.crbs.ucsd.edu:8080/incf-services/service/ABAServiceController?request=DescribeProcess&output=xml

An example output is (fragment):


<?xml version="1.0" encoding="UTF-8" ?> <wps:ProcessDescriptions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.opengis.net/wps" xmlns:wps="http://www.opengis.net/wps" xmlns:ows="http://www.opengis.net/ows" version="1.0.0" xmlns:ogc="http://www.opengis.net/ogc" xmlns:xlink="http://www.w3.org/1999/xlink" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsGetCapabilities_request.xsd">
	<ProcessDescription>
		<ows:Identifier>Get2DImagesByPOI</ows:Identifier>
		<ows:Title>Get 2D Image at POI</ows:Title>
		<ows:Description>Returns 2 Dimensional images based on point of interest on the map</ows:Description>
		<DataInputs>
			<Input>
				<ows:Identifier>X</ows:Identifier>
				<ows:Title>Value in X dimension</ows:Title>
				<ows:Abstract>Value in X dimension as defined in the SRS </ows:Abstract>
				<LiteralData>
					<ows:DataType ows:reference="xs:double" />
				</LiteralData>
			</Input>
			<Input>
				<ows:Identifier>Y</ows:Identifier>
				<ows:Title>Value in Y dimension</ows:Title>
				<ows:Abstract>Value in Y dimension as defined in the SRS </ows:Abstract>
				<LiteralData>
					<ows:DataType ows:reference="xs:double" />
				</LiteralData>
			</Input>
			<Input>
				<ows:Identifier>Z</ows:Identifier>
				<ows:Title>Value in Z dimension</ows:Title>
				<ows:Abstract>Value in Z dimension as defined in the SRS </ows:Abstract>
				<LiteralData>
					<ows:DataType ows:reference="xs:double" />
				</LiteralData>
			</Input>
			<Input>
				<ows:Identifier>srsCode</ows:Identifier>
				<ows:Title>Altas Space Reference System Code</ows:Title>
				<ows:Abstract>Name of an atlas space such as ABAvoxel</ows:Abstract>
				<LiteralData>
					<ows:DataType ows:reference="xs:string" />
				</LiteralData>
			</Input>
		</DataInputs>
		<ProcessOutputs>
			<Output>
				<ows:Identifier>ImageURL</ows:Identifier>
				<ows:Title>2D Image at POI result</ows:Title>
				<ows:Abstract>2D Image at POI result</ows:Abstract>
				<ComplexOutput>
					<Default>
						<Format>
							<MimeType>text/ascii</MimeType>
							<MimeType>text/html</MimeType>
							<MimeType>application/vnd.incf.waxml</MimeType>
							<Encoding>UTF-8</Encoding>
							<Schema>http://foo.bar/waxml/201001/response.xsd</Schema>
						</Format>
					</Default>
					<Supported>
						<Format>
							<MimeType>text/xml</MimeType>
							<Encoding>UTF-8</Encoding>
							<Schema>http://foo.bar/gml/3.1.0/polygon.xsd</Schema>
						</Format>
						<Format>
							<MimeType>text/html</MimeType>
							<Encoding>UTF-8</Encoding>
						</Format>
					</Supported>
				</ComplexOutput>
			</Output>
		</ProcessOutputs>
	</ProcessDescription>
</wps:ProcessDescriptions>


Notes: WPS 2.0 is now nearing adoption. Per Albert’s question: there is a recent discussion paper on how semantic annotations are incorporated in WPS and other OGC standards: http://portal.opengeospatial.org/files/index.php?artifact_id=34916


3.	ListSRSs: this call is not yet implemented. It will return a list of coordinate reference systems with their metadata as defined in the attached schema (see section 3). The request shall be implemented at both atlas hubs and at the INCF central server. Atlas hubs don’t need to maintain coordinate space definitions that are already registered at the INCF Central server – but they shall maintain definitions of coordinate spaces that are unique for this hub.
The basic request, in WPS syntax, is:
{BaseService}request=Execute&Identifier=ListSRSs

4.	DescribeSRS (SRSCode) is a companion request that provides detailed information about a spatial reference system, including SRS metadata (as above), and possibly features, fiducials, and other components as specified in the SRS model. We expect that features, fiducials and slides will be listed and described by separate calls, which will be defined once the SRS information model is finalized.  A series of such calls should be sufficient to populate the relational structure describing coordinate reference systems at the INCF Central. See Section 3 (“atlas space registries”) for more details.
The basic request, in WPS syntax, is:

{BaseService}request=Execute&Identifier=DescribeSRS&DataInputs=srsCode={Code}

5.	ListTransformations, DescribeTransformation, GetTransformationChain. These requests reflect information model for coordinate transformations, which is being developed – hence we don’t provide definite specifications here. So far, a GetTransformationInfo (fromSRSCode, toSRSCode, filter) request has been implemented to derive a transformation chain between any two known transformations (now renamed to GetTransformationChain). The filter parameter may be used to specify the area in the brain for which the transformation chain will be computed. We expect that local transformations will be developed in addition to whole-brain transformations, providing better transformation accuracy for certain parts of the brain (e.g. hippocampus). Restricting chains of coordinate transformations to such conversions, if available, would produce better transformation accuracy.

In the group above, ListTransformations (without parameters) will return a list of available transformations implemented at a hub or at a central server. and DescribeTransformation (transformationCode) returns a description of transformation.

Requests 3 and 4 are primarily needed for populating INCF Central tables and for exposing the content of the INCF Central server. Therefore, they are not required initially (initially, we populate all these tables manually). The GetTransformationChain request, however, appears important to implement immediately, for tracing lineage of transformations, especially as we expect multiple coordinate transformations developed and posted by different groups (i.e. at different hubs) and providing different transformation accuracy in different parts of the brain. Therefore, we mock up the response to this request below. The <coordinateTransformationChainResponse> element contains a <queryInfo> element of type <QueryInfoType>, and a <coordinateTransformationChain> element of type <coordinateTransformationChainType>.  

The base request is:
{BaseService}request=Execute&Identifier=GetTransformationChain&DataInputs=inputSrsCode={Code};targetSrsCode={Code};filter={string}
A sample response is:

<coordinateTransformationChainResponse 
xmlns:xlink="http://www.w3.org/1999/xlink" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:wtr="http://www.incf.org/waxML/" 
xmlns="http://www.incf.org/waxML/1.0201002/">
    <queryinfo>
        <queryURL name="GetTransformationChain">URL</queryURL>
        <criteria>
            <input name="fromSRSCodeinputSRSCode">paxinos</input>
            <input name="toSRSCodetargetSRSCode">ABAreference</input>
        </criteria>
    </queryinfo>
    <coordinateTransformationChain>
        <coordinateTransformation order="1" 
          code="Paxinos2WHS"  implementingHub="UCSD" 
           fromSRSCode="Paxinos" toSRSCode="WHS"
           accuracy="xxx">requestURL</coordinateTransformation>
        <coordinateTransformation order="2"
          code="WHS2AGEA" implementingHub="ABA" 
          fromSRSCode="WHS" toSRSCode="AGEA" 
          accuracy="xxx">requestURL</coordinateTransformation>
        <coordinateTransformation order="3" 
          code="AGEA2ABAvoxel" implementingHub="ABA"
          fromSRSCode="AGEA" toSRSCode="ABAvoxel" 
          accuracy="xxx">requestURL</coordinateTransformation>
        <coordinateTransformation order="4" 
          code="ABAvoxel2ABAreference" implementingHub="ABA"
          fromSRSCode="ABAvoxel" toSRSCode="ABAreference" 
          accuracy="xxx">requestURL</coordinateTransformation>
    </coordinateTransformationInfo>
</coordinateTransformationInfoResponse>

Populating <queryInfo> is encouraged though not required. Using <queryInfo> allows users to re-examine the source of information and trace the lineage if needed. Often, a single query URL and a list of inputs is not sufficient to define a source of returned data completely. In this case, additional <note> elements with @type=”sourceUrl” are suggested.
Note that the <coordinateTransformationChain> element describes a list of coordinate transformations that shall be called in sequence to get from the source to the target coordinate system.
It is expected that this call will be implemented against the table of registered coordinate transformations at the INCF Central, to support chaining coordinate translation services hosted by several different hubs. Respective GetTransformationChain methods hosted by each hub will return information about single transformations.

Further, CoordinateTransformation would be treated as a type of POITransformation, the latter including also label-based and rule-based transformations.

6.	GetStructureNamesByPOI(POI, outputVocabulary, filter) returns name(s) of segmented anatomic structures at the point of interest, in a specified vocabulary.
An example implemented request is:
 http://incf-dev-mapserver.crbs.ucsd.edu:8080/incf-services/service/ABAServiceController?request=GetStructureNameByPOI&srsCode=ABAVoxel&x=295.0&y=113.0&z=146.0&vocabulary=ABAVoxel&filter=structureset:Fine&output=html
The same request in WPS syntax generating Html output:
{BaseService}request=Execute&identifier=GetStructureNamesByPOI&DataInputs=srsCode=ABAVoxel;x=295.0;y=113.0;z=146.0;vocabulary=ABAVoxel;filter=structureset:Fine&ResponseForm=text/html
Same, generating WaxML output:
{BaseService}request=Execute&identifier=GetStructureNamesByPOI&DataInputs=srsCode=ABAVoxel;x=295.0;y=113.0;z=146.0;vocabulary=ABAVoxel;filter=structureset:Fine

 Currently, the call returns a single structure. In the future, it will be extended to return a list of structures ranked by relevance, or proximity to the POI (or by some other defined rule). This service is not mandatory, but expected in a majority of atlas cases, where there is a correspondence between coordinates and structures.
The inputs are: 
-	POI is defined as (X,Y,Z) in a known spatial reference system (srsCode). 
-	The “vocabulary” term will generally be the same as the spatial reference system. However, we shall allow for multiple segmentations of the same coordinate space (e.g. there are canonical Paxinos structures, many of them not closed in the original atlas; in addition there are results of segmenting 3D space built over Paxinos slices; other segmentations may be developed over 3D volumes registered to the Paxinos space). 
-	In each case, the definition of returned structure may be different. For example, ABA allows to return “anatomic” or “fine” structures. In the Paxinos case, we may return the closest label or a collection of labels. This information is specified in the “filter” string input, as it will be unique for each source.
The output is: a) HTML: a web page specifying the vocabulary and the term, both the abbreviation and the complete term, b) XML. In the latter case, it includes a <queryinfo> element which includes the query string and the POI in canonical form, and a structure for <StructureTermsResponse>, something like:
<structureTermsResponse xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gml="http://www.opengis.net/gml/profile/sfgml/1.0" xmlns:wax="http://www.incf.org/WaxML/" xmlns="http://www.incf.org/WaxML/0201002/">
    <queryinfo>
        <queryURL name="GetStructureNamesByPOI">URL</queryURL>
        <criteria>
            <input name="POI">
                <gml:Point srsName="INCF:ABAvoxel">
                    <gml:pos>x,y,z</gml:pos>
                </gml:Point>
            </input>
            <input name="StructureVocabulary">ABAvoxel</input>
            <input name="StructureFilter">structureset:Fine</input>
        </criteria>
    </queryinfo>
<structureTermsResponse>
    <structureTerm>
        <structureCode vocabularycodeSpace="ABAvoxel" default="true" structureID="1369">HIP</structureCode>
        <structureName>Hippocampus</structureName>
        <structureDescription>Hippocampus, segmented   </structureDescription>
        <feature>
            <centroid>
                <gml:Point srsName="INCF:ABAvoxel">
                    <gml:pos>x,y,z</gml:pos>
                </gml:Point>
            </centroid>
            <gml:boundedBy>
                <gml:Envelope srsName="WHS">…</gml:Envelope>
            </gml:boundedBy>
            <url  srsCode="ABAvoxel">URI
            </url>
            <format>shape</format>
        </feature>
    </structureTerm>
</structureTermsResponse>

Notice the use of the gml namespace to describe spatial characteristics of the structure (centroid and bounding envelope). The GML simple features profile is defined at http://www.ogcnetwork.net/gml-sf.  
The meaning of “feature” vs “structure” should be further discussed and defined. Note that in OGC standards “features” refer to entities that have geometric properties. “Structure” may be reserved for constructs that include multiple geometric features, and other properties – as in the example above.
In this initial version of the method, we do not require to specify the criterion for selecting a structure to return. The rule by which particular structure names, and their sequence, are returned is up to the hub to specify. Moreover, the currently implemented version of the request returns a single structure rather than a collection of structures (e.g. the nearest label, or the smallest segmented for the POI). In the future, the hub may specify the relationship used to return the structure name, e.g. “the closest label”, or “finest structure”, or “parent of structure pointed to with xlink:href. For example: <structureTerm order=”1” relationship=”finest”>. This extension is slated for future versions, in the expectation that PONS services will be able to pick up the structure name in a specified vocabulary, and translate it to other names as needed, for example, for gene search (in the most typical case, it would translate to a parent structure for which gene searches are available). In the future version(s) of this request, the rule may be specified explicitly using spatial relationships, e.g. returning a set of structure names that are in spatial relationship R to the POI, where R can be constructed based on containment or other topological properties, proximity, etc. (“inside”, “nearest”, “within 100 microns”, etc.). Additional spatial relationships R may be supported if ROI is passed as part of the request instead of POI. However, few atlases support ROI-based requests at present (with the exception of the SMART atlas), so this may be implemented after other hubs move in this direction. Until then, a GetStructureNamesByROI will belong to extended hub requests.
The “url” element points to a 3D representation of a structure, which could be an octree-or 3D R-tree-indexed collection of voxels, a mesh, a segment set, a 2d polygon stack, a 2d pixel stack, or a 3D server where the structure can be requested. A companion method Get3DStructureShape (URI, outputtype), or more generally, DescribeStructure, would return an XML representation of the structure in a specified format (e.g. in X3D).
If the output type is HTML, the hub, or the wrapping service, is free to implement an agreeable output with structure name and vocabulary, and other ingredients such as pointers to concept specification in a wiki or other concept-related metadata or visualizations.
Exceptions: POI out of bounds; no structure found
Note that a hub may expose more than one set of segmented structures: this is either handled by the filter string, or by setting up an additional service controller.
7.  TransformPOI. This is a mandatory method to be exposed by a hub if the hub registers data to a spatial reference system other than WHS. 
An example method call as implemented is 
http://incf-dev-mapserver.crbs.ucsd.edu:8080/incf-services/service/UCSDServiceController?request=SpaceTransformation&fromSRSCode=WHS&toSRSCode=paxinos&x=280.0&y=112.0&z=162.0&output=html
The suggested method signatures are:
Html:
{BaseService}request=Execute&Identifier=TransformPOI&DataInputs=inputSRSCode=WHS;targetSRSCode=paxinos;x=280.0;y=112.0&z=162.0&filter=&ResponseForm=text/html
WaxMl
{BaseService}request=Execute&Identifier=TransformPOI&DataInputs=inputSRSCode=WHS;targetSRSCode=paxinos;x=280.0;y=112.0&z=162.0&filter=
Text:
{BaseService}request=Execute&Identifier=TransformPOI&DataInputs=inputSRSCode=WHS;targetSRSCode=paxinos;x=280.0;y=112.0&z=162.0&filter=&ResponseForm=text/plain


It is expected that each hub implements translations between at least one locally-unique coordinate system, and WHS. For example, the ABA hub currently implements direct and reverse translations between WHS and AGEA, at the same time supporting translations between AGEA and ABAvoxel space, and between ABAvoxel and ABAreference. The method inputs include fromSRSCode, toSRSCode, POI coordinates in the fromSRSCode space, and the output type (XML or HTML).
If output type is XML, each response includes two parts: <queryinfo> containing the request specification (request URL plus a formal POI representation), and <POI>, containing the computed POI. The POI specification follows GML simple features conventions:
<tranformationResponse xmlns:wax="http://www.incf.org/WaxML/" 
xmlns="http://www.incf.org/WaxML/201002/">
    <queryinfo>
        <queryURL name="TransformPOI">URL</queryURL>
        <criteria>
            <input name="POI">
                <gml:Point srsName="INCF:Paxinos">
                    <gml:pos>x y z</gml:pos>
                </gml:Point>
            </input>
        </criteria>
    </queryinfo>
    <POI>
        <gml:Point srsName="INCF:ABAvoxel">
            <gml:pos>x y z</gml:pos>
        </gml:Point>
    </POI>
</transformationResponse>
An example of “text/plain” output  may be:
POI:
	SRSName: INCF:ABAvoxel
	Point: x y z
It is further expected that once a hub is registered at INCFCentral, space transformation metadata will be added to a “space transformations” table at the INCFCentral, while a space description will be added to the SRS structures. With transformations from all hubs registered at INCFCentral, one shall be able to issue arbitrary space transformation calls, e.g. with fromSRScode = paxinos and toSRScode = ABAreference, which should trigger a workflow that chains several transformations: paxinos->WHS; WHS->AGEA; AGEA->ABAvoxel; ABAvoxel->ABAreference. It may be further arranged with the hub that transformation code is implemented at the INCF Central server.

8.	Get2DImagesByPOI. Similarly to GetStructureNamesByPOI, this is a method we typically expect to be implemented by most atlas hubs. Similarly to GetStructureNamesByPOI, hubs are free to interpret this request to return references to either one or a stack of images, and select a rule for image selection. The selection may implement search over spatial registry within a user-defined or predefined tolerance (as in the case of images registered for display in Smart atlas) or some procedure deriving an appropriate image numerically from POI. We expect this call to be supported at INCF Central as well, over the central spatial registry harvested from individual hubs.
A sample request as implemented is 
http://132.239.131.188:8080/incf-services/service/ABAServiceController?request=get2DImageAtPOI&srsCode=ABAvoxel&x=263&y=159&z=227&width=217&height=152&filter=maptype:coronal&output=html

It combines Get2DImagesByPOI functionality, and GetMap/GetImage/GetCoverage functionality. In the next version these should be handled separately, recognizing that images can be returned by another known service protocol, e.g. WMS (web mapping service).

The proposed requests are:

Html
{BaseService}request=Execute&Identifier=get2DImagesByPOI&DataInputs=srsCode=ABAvoxel;x=263;y=159;z=227; filter=maptype:coronal&ResponseForm=text/html

JSON
{BaseService}request=Execute&Identifier=get2DImagesByPOI&DataInputs=srsCode=ABAvoxel;x=263;y=159;z=227;filter=maptype:coronal&ResponseForm=text/json

WaxMl
{BaseService}request=Execute&Identifier=get2DImagesByPOI&DataInputs=srsCode=ABAvoxel;x=263;y=159;z=227;filter=maptype:coronal


The inputs to this request are:
-	Specification of POI, including X,Y,Z coordinates and their srsCode
-	Filter: any additional hub-specific string defining a rule for selecting images
-	Output: either html or xml (or JSON?)
In case of HTML, the returned document may represent a menu of images, or a single image.
In case of XML, the returned document will contain the following parts: a)the <queryinfo> element, similar to examples in previous requests, and b) a list of images returned, each with a URL of the image and its spatial characteristics, and perhaps a thumbnail (essentially, the content of the spatial registry for the selected set of images).
<imagesResponse>
    <queryinfo>
        <queryURL name="Get2DImagesAtPOI">URL</queryURL>
        <criteria>
            <input name="POI">
                <gml:Point srsName="INCF:ABAvoxel">
                    <gml:pos>x,y,z</gml:pos>
                </gml:Point>
            </input>
            <input name="widthAndHeight">N,M</input>
            <input name="Filter">maptype:coronal </input>
        </criteria>
    </queryinfo>

    <image2DCollection>
        <image2D>
            <imageSource thumbnail="URL" metadata="URL" name="…" srsName=".." type="WMS-jpg|WMS-png|WMS-gif|zoomify|url" format="image/png|image/gif|image/jpg" relevance="###">URL
            </imageSource>
            <imagePosition width="N" height="M">
                <imagePlaneEquation srsName="…">a,b,c,d</imagePlaneEquation>
                <imagePlanePlacement srsName="…">a,b,c,d,e,f</imagePlanePlacement>
                <corner position="topleft">
                    <gml:Point srsName="INCF:ABAvoxel">
                        <gml:pos>x,y,z</gml:pos>
                    </gml:Point>
                </corner>
                <corner position="bottomleft">
                    <gml:Point srsName="INCF:ABAvoxel">
                        <gml:pos>x,y,z</gml:pos>
                    </gml:Point>
                </corner>
                <corner position="topright">
                    <gml:Point srsName="INCF:ABAvoxel">
                        <gml:pos>x,y,z</gml:pos>
                    </gml:Point>
                </corner>
                <corner position="bottomright">
                    <gml:Point srsName="INCF:ABAvoxel">
                        <gml:pos>x,y,z</gml:pos>
                    </gml:Point>
                </corner>
            </imagePosition>
        </image2D>

        <image2D> …
        </image2D>
    </image2DCollection>
</imagesResponse>
Exceptions: out of bounds; no images found.
Similarly to GetStructureInfoByPOI, a hub may expose more than one set of images: this is either handled by the filter string, or by setting up an additional service controller.

9.	GetMap/GetCoverage. These requests are not specified in WaxML because they are expected to conform to other protocols. For example, in WMS Implementation Specification, the GetMap request would take the WMS service URL from the previous request, as well as image parameters, to generate an image fragment. In the geospatial context, this request is described as follows:

“GetMap (required): The GetMap request returns a map image whose geospatial and dimensional parameters are well defined. The map operation of the GetMap request is invoked by a client to get a rectangular set of pixels. These pixels contain a picture of a map covering a geographic area or a set of graphic elements that lie in a geographic area. The GetMap request allows the WMS client to specify distinct layers, the spatial reference system (SRS), the geographic area, and other parameters describing the returned map format. Upon receiving the GetMap request, a WMS server will either satisfy the request or throw an exception in accordance with the exception instructions contained in the GetMap request.”
Note that this service would be supported by a hub, and declare its capabilities via a WMS GetCapabilities request

10.	Additional (or extended) hub services:
These services are unique for certain hubs, and only sketched out here. They include, for example:
a)	Method GetCorrelationMapByPOI  (implemented at ABAserviceController only)

Sample as implemented:

http://132.239.131.188:8080/incf-services/service/ABAServiceController?request=getCorrelationMap&srsCode=ABAVoxel&x=263&y=159&z=227&filter=maptype:coronal&output=txt 
 
Proposed signatures:

Text Format 
{BaseService}&request=Execute&Indentifier=getCorrelationMapByPOI&DataInputs=srsCode=ABAVoxel;x=263;y=159;z=227;filter=maptype:coronal&ResponseFormat=text/plain 
WaxMl
{BaseService}&request=Execute&Indentifier=getCorrelationMapByPOI&DataInputs=srsCode=ABAVoxel;x=263;y=159;z=227;filter=maptype:coronal&ResponseFormat=application/waxml

b)	Method GetGenesByPOI  (implemented at ABAserviceController only)
Sample as implemented:
http://132.239.131.188:8080/incf-services/service/ABAServiceController?request=GetGenesByPOI&srsCode=ABAVoxel&x=263&y=159&z=227&output=txt

Proposed signatures:
Text Format
{BaseService}request=Execute&Identifier=GetGenesByPOI&DataInputs=srsCode=ABAVoxe;x=263;y=159&z=227& ResponseFormat=text/plain
WaxMl
{BaseService}request=Execute&Identifier=GetGenesByPOI&DataInputs=srsCode=ABAVoxe;x=263;y=159&z=227& ResponseFormat=application/waxml


Both methods will reuse WaxML or GML constructs for constructing responses, including standardized <queryinfo> elements, appended with <correlationMap> and <GeneExpressions> structures respectively. These structures may follow other emerging XML schemas in the community, to be determined.

2. Architecture outline

The hub services described above are expected to be provided by individual hubs. Since we deal with a collection of legacy atlas servers with variety of query and access mechanisms, it is expected that each hub will be wrapped in a “ServiceController” wrapper (or more than one ServiceController wrapper, if exposing several versions of spaces, segmentations and image sets). This wrapper will provide a collection of core services and extended hub services (e.g. GetCorrelationMap described above) that can be further registered at the INCF Central server (Figure 1)

The functions of the INCF Central server will include:
-	Allow hub data managers to register their hubs to the INCF Central, and edit hub metadata
-	Support harvesting hub metadata into a collection of INCF Central tables
-	Support discovery hub metadata, including information about known coordinate reference systems, spatial transformations, functionality of each hub, and registered spatial datasets (e.g. images)
-	Spawn data queries to atlas hubs
-	Perform coordinate transformations and chain transformations as necessary
-	Support subscription/notification of users as information becomes available in a catalog on a particular topic or area.


The software stack for INCF atlas hub includes therefore:
-	A collection of data loaders tuned to specific type of data (e.g. CCDB registration can be re-used here). The list of data types to be handled by hubs is as in Figure 2 – though not all hubs will support all data types.
-	These loaders populate a relational structure for each specific type of data (e.g. gene expression data loader takes Excel or CSV files and puts them into RDBMS), or a database catalog plus file system (as with images). Indexes are rebuilt and databases are tested for outliers, completeness, etc. An empty canonical RDBMS container and directory structure shall be provided as part of hub.
-	A service template for each data type is configured to point to that local RDBMS (essentially, by editing connection string and metadata), and the service is automatically deployed
-	The service registry at the local hub is updated with the new service (so that GetCapabilities and similar requests reflect the new functionality)
-	INCF Central’s registry re-harvests the hub metadata, including the new service (at regular intervals, or as triggered by service registration). This is done by calling hub’s GetCapabilities and DescribeProcess services, followed by calls populating the spaces and transformations tables, and INCF Central metadata catalog.
-	Hub data manager attempts to tag local data available via the new service, to both spatial and semantic frameworks maintained at INCF Central. This is done in the “registration” part of the INCF Central Application
o	If local images and 3D volumes are registered to some locally-unique SRS, this SRS needs to be declared to INCFCentral, mapped to WHS, and additional transformation service created;
o	If local images and 3D volumes are not registered to any spatial framework, they shall be registerable using INCF-Central tools (e.g. Jibber/Jetsam)
o	If local terms are registered to some local version of ontology, this ontology needs to be loaded in INCF Central repository of ontologies, and necessary cross-walks and crosswalk services developed; then term mapping shall be validated
o	If local terms are not registered to a local ontology, they need to be tagged to INCF Central ontology concepts using thematic mapper and similar tools.
o	The newly developed service shall be validated for common semantics-based discovery and space-based queries, then it can be curated into a production set of services, and updated at INCF Central as operational service.
-	Once the new hub service is completely registered at INCF Central by a hub data manager and submitted for publication, INCF Central curator makes this service available in the production environment through INCF Central discovery system. The discovery system may have one or more client applications, e.g. the UCSD 3D Atlas Integration client, BrainExplorer, and MBAT.
-	Operational roles envisioned in the above scenario are: a) hub data manager, and b) INCF Central curator.























3. Registries of atlas spaces and transformations at INCF Central.

The role of INCF Central is to host information about atlas hubs, support a discovery system over metadata harvested from atlas hubs, and let registered users add/update hub registrations. In addition, the INCF Central shall host several key infrastructure services that supply standards-compliant information about (a) Waxholm and other known spatial reference systems, (b) spatial transformations between Waxholm and other atlases, (c) INCF-adopted ontology and other registered ontologies, and (d) ontology cross-walks. Note that transformations hosted by INCF Central are expected to be relatively light-weight (as described in the SpaceTransformation service above); if any heavy lifting is expected at query time (such as warping images on demand) – this shall reside at the hubs to minimize data transfer.  At registration time, INCF Central may support uploading and registering of spatial data to its associated hub; however, hub data managers are encouraged to maintain their own spatial registries exposed via standard interfaces such as CSW/ebRIM.( http://www.opengeospatial.org/standards/cat)

A registry of spatial coordinate systems is one of the key components of global spatial data infrastructure. In the earth science world, EPSG Geodetic Parameter Dataset (http://info.ogp.org.uk/geodesy/Geodetic.html) is widely used. For INCF DAI, we propose to create a similar standards-setting repository of neuroscience coordinate systems. A model of this registry is now being discussed at the https://confluence.crbs.ucsd.edu/display/SISL/INCF+Standards pages. 

The following tables are included:
•	SRS (spatial reference systems): SRSid, SRSCode, SRSName, SRSDescription, SRSVersion, SRSAuthor, SRSDateSubmitted, Origin, NeuroPlusX, NeuroMinusX (and the same for Y and Z), Area of Use (some SRSes can be defined only locally), DimensionMinX, DimensionMaxX (and the same for Y and Z), DescriptionURI, Units, FileURL, FileFormat, Abstract, DerivedFrom, DerivedMethod
•	Features (anatomic features segmented in 2D or 3D): FeatureID, FeatureCode, FeatureName, FeatureType, SRSCode (i.e. to which space in SRStable this feature belongs). Vocabulary, Pointer to spatial objects/SVA files, Author of segmentation, Date of submission, Version, Certainty level (or pointer to certainty description). [possibly, we call this table Structures]
•	Fiducials (derived from Features and used to related one SRS to another): FigucialId, FiducialCode, FiducialName, FiducialType (instrument artifact, or derived from a feature), DerivedFrom (or some provenance description, derivation function, or pointer to a table describing such functions), certainty_level (as propagated from features), SDO
•	Orientations (describe the meaning of coordinate axes, which may be complex for development brain or tilted volumes/images): NeuroPlusX (etc) defined as some functions of "anterior", "posterior", "left", "right", "dorsal", "ventral".
•	Slices (collection of slices organizing segmented 2D Features): SliceID, SliceCode, Slicetype (coronal, sagittal), SRSCode, ConstantOrientation, ConstantValue, Xorientation, Yorientation, Description
•	Additional tables: rules_for_fiducials, projects, authors, vocabularies (up to the metadata TF to decide)

Information from this registry will be available via ListSRSs and DescribeSRS requests described above, and potentially other requests against additional tables.

4. Services at INCF Central
INCF Central’s functionality is outlined in Section 2. This includes registration/harvesting; data discovery; query orchestration; caching of framework datasets and operations (in particular, spatial operations and transformations); monitoring/load balancing; subscription/notification. The following tentative list of services is proposed (maintaining compatibility with INCF Hubs API as maximally possible):

1)	ListHubServices: present the content of the Hubs registry with minimal ISO/Dublin Core metadata. 
2)	DescribeHub (HubCode)
3)	GetCapabilities and DescribeProcess (for INCF Central server) – basically listing resources registered at the server, and each process 
4)	ListGenes, ListStructures
5)	ListSRSs, DescribeSRS (also ListVocabularies, DescribeVocabulary – but these are up to PONS – possible wrappers for NIF services)
6)	ListTransformations, DescribeTransformation, GetTransformationChain
7)	GetStructureNameByPOI, and other POI-based methods (usually passing them to the hubs)
8)	RegisterHub and HarvestHub methods (to be specified)
9)	GetHubStatus (HubCode)
10)	GetCatalogUpdates (for last day? Last week?). also Subscribe methods



5. Physical implementation of a hub 

We are considering two types of INCF atlas data hubs, referred to as “standard hub” and “hybrid hub”. So far, the demo implementation followed a “hybrid hub” model, where some functions are available from an independently managed legacy server (e.g. ABA, EMAP/EMAGE, Smart Atlas). This remote functionality is wrapped into standard service requests described in Section 1. In addition, several core but missing requests are added: those implementing GetCapabilities and DescribeProcess calls, spatial transformations, and anatomic structure lookup. In this fairly lightweight model, a hybrid hub hosts (a) service controller for the hub, with automatically updated GetCapabilities/DescribeProcess requests as the hub content changes, (b) service wrappers of remote services, (c) description of local coordinate spaces and transformations to and from WHS. We assume that hybrid hubs do their own database and services management, and are not interested in additional web presence.

A “standard hub” is intended for atlas groups that don’t have web service presence, and would like to setup a hub from scratch. In this case, the hub software stack may include backend services, providing secure access to dataset and collection management, portal components with a variety of tools, containers for other services, etc. Earlier, we referred to this setup as “Neurohub”. It is expected that the atlas hub functions (data loaders, canonical RDBMS schemas, registries, spatial and semantic registration workflows, image server, atlas hub services etc.) would reside in an “atlas container” implemented within Neurohub. The standard hub’s application services (as described in section 1) will still be registered at the INCF Central in the same fashion as those from a hybrid hub. 

The purpose of the above outline is to describe functionality and implementation of a hub from the Atlasing perspective. Text describing how the atlas service interacts with other components of a hub (e.g. portal, collaborative tools, backend data management, etc.) is beyond the scope of this document. This, however, will become the main focus at the implementation stage of atlas hub service. Therefore, we provide a glimpse of the anticipated hardware and software model of a Neurohub, which will serve as a container for atlas services. 

One of the “standard hubs” we envision will be co-located with the INCF Central server itself. This hub will be used by researchers who, for any reason, prefer not to stand a separate hub with the above defined functionality, but rather upload their data to INCF directly.

This flexible definition of a hub allows for other types of service providers to be registered to INCF Central in the same fashion. These could include (see Figure 4):
-	National hubs (as long as they provide a list of services through GetCapabilities and DescribeProcess mechanism, and perhaps support RSS (ideally, GeoRSS) feeds that can be registered at INCFCentral)
-	Community software repositories such as NITRC (as long as they support GetCapabilities and expose their holdings via CSW/ebRIM mechanism)
-	Specialized resources, such as simulation providers or ontology providers and marked-up resource providers such as NIF (as long as they are exposed via some discovery and access services that can be used to harvest information at some level)

 
Figure 4. INCF infrastructure of Neuro-hubs

At the physical level, a NeuroHub may represent a collection of virtual machines (VMs), managed and load-balanced. These machines could host atlas services (as described above), data management/data sharing services and backend, collaboration tools, ontology, resource registry, data discovery system, etc. A more detailed specification of the deployment model is below.

6. HUB deployment model and additional requirements

As outlined above, a NeuroHub may represent a collection of virtual machines (VMs), with failover and load-balancing. The VMs are established per functional group (precise VM slicing to be defined): for database server, collection/data management, atlas services, portal framework with associated communication/collaboration tools, workflow services, resource registry, etc. In a standard deployment configuration, 2 physical servers with identical configuration (primary and failover), plus a single shared storage, will be provided. Figure 5 shows the physical organization. The system itself can also (based on hardware and VM configuration) load balance VMs across the two nodes. 
 
Figure 5. Deployment model of an INCF Hub
 
The specific set of VMs at each hub would vary. An example of application services would be the atlas services described above. We anticipate that separate application-level services (and eventually VMs) would be needed for different hub maintainers (i.e. some data types may be specific for a group. Some of the groups of data types managed by the INCF infrastructure would include (also shown in Fig 3):  
•	2D images 
•	2D vector segmentations 
•	3D volumes 
•	Connectivity data 
•	Cell models 
•	Electrophysiology data 
•	Surfaces 
•	Phenotype/behavioral data 
•	FMRI (4+D) 
•	Time series 
•	Gene expression data 
•	Distortion fields, numerics 
•	Simulation results and animations 
•	Annotations 
•	Publications 
For each of these data type groups, the infrastructure should include: data loaders (or other services for harvesting, ingesting and registering data of these types); data storage with canonical relational or XML schemas; registries; spatial and semantic registration workflows; specialized database or image servers (e.g. servers for large 2D and 3D imagery such as CCDB); client-side applications for resource registration, curation, visualization, resource discovery (such as services provided by NIF), analytical workflow composition (e.g. such as the services provided by projects such as CAMERA), annotation, etc.  In some instances, such components exist, usually as individual tools. Development of these components as part of the INCF infrastructure depends on the adoption of international community standards for exchanging data of each type – the process which INCF is well-positioned to lead. 
Additional code management and deployment requirements to take into account (unsorted so far):
•	managing all project code in a code management system;
•	release management and nightly builds, with a make tool/buildbot;
•	ability to deploy as VMs on different hardware (including notebooks);
•	project wiki/confluence;
•	unit testing and documentation;
•	central server with a hot page, resource consumption monitoring, pointers to additional service clients (in addition to a browser-based client integrated with – possibly – GI-Cat-based portal);
•	ability to maintain an audit trail on transformations (including detailed description of the code used at the hubs for transformations – possibly pointers to publications); 
•	following standard signatures of GetFeatureInfo; ListFeatures; etc.;
•	graceful handling of empty results and errors: generally, when a feature or gene request in a particular vocabulary returns an empty result then let the application handle fallback;

